const {
  Client,
  EmbedBuilder,
  Events,
  GatewayIntentBits,
  Partials,
  PermissionsBitField,
} = require('discord.js');
const { discordToken, facebookUserAgent, maxFacebookEmbeds } = require('./config');
const { extractFacebookLinks, fetchFacebookMetadata } = require('./services/facebookMetadata');

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent],
  partials: [Partials.Channel],
});

client.once(Events.ClientReady, (readyClient) => {
  console.log(`✅ Logged in as ${readyClient.user.tag}`);
});

client.on(Events.MessageCreate, async (message) => {
  try {
    await handleMessage(message);
  } catch (error) {
    console.error('Unexpected error while handling message:', error);
  }
});

async function handleMessage(message) {
  if (!message || message.author?.bot) {
    return;
  }

  const channel = message.channel;
  if (!channel || typeof channel.isTextBased !== 'function' || !channel.isTextBased()) {
    return;
  }

  if (message.guild) {
    const me = message.guild.members.me;
    const permissions = me ? channel.permissionsFor(me) : null;
    if (permissions) {
      const needsThreadPermission = typeof channel.isThread === 'function' && channel.isThread();
      const requiredSendPermission = needsThreadPermission
        ? PermissionsBitField.Flags.SendMessagesInThreads
        : PermissionsBitField.Flags.SendMessages;

      if (!permissions.has(requiredSendPermission)) {
        return;
      }
      if (!permissions.has(PermissionsBitField.Flags.EmbedLinks)) {
        return;
      }
    }
  }

  const links = extractFacebookLinks(message.cleanContent || message.content || '');
  if (!links.length) {
    return;
  }

  const targets = links.slice(0, maxFacebookEmbeds);
  for (const url of targets) {
    try {
      await channel.sendTyping();
    } catch (typingError) {
      console.warn('[FacebookEmbed] Unable to send typing indicator:', typingError.message);
    }

    try {
      const metadata = await fetchFacebookMetadata(url, { userAgent: facebookUserAgent });
      if (!metadata) {
        continue;
      }

      const embed = buildFacebookEmbed(metadata);
      await channel.send({
        embeds: [embed],
        allowedMentions: { repliedUser: false },
      });
    } catch (error) {
      console.error(`[FacebookEmbed] Unable to render preview for ${url}:`, error.message);
    }
  }
}

function buildFacebookEmbed(metadata) {
  const embed = new EmbedBuilder()
    .setColor(0x1877f2)
    .setURL(metadata.url)
    .setTitle(metadata.title || 'Facebook link');

  if (metadata.siteName) {
    embed.setAuthor({ name: metadata.siteName });
  }

  if (metadata.description) {
    embed.setDescription(truncate(metadata.description, 500));
  }

  if (metadata.image) {
    embed.setImage(metadata.image);
  }

  embed.setFooter({ text: 'Facebook preview generated by bot' });
  return embed;
}

function truncate(text, maxLength) {
  if (!text || text.length <= maxLength) {
    return text;
  }
  return `${text.slice(0, maxLength - 1)}…`;
}

client
  .login(discordToken)
  .catch((error) => {
    console.error('Failed to login to Discord:', error);
    process.exit(1);
  });

function shutdown(signal) {
  console.log(`Received ${signal}. Shutting down Discord client.`);
  client.destroy();
  process.exit(0);
}

process.on('SIGINT', () => shutdown('SIGINT'));
process.on('SIGTERM', () => shutdown('SIGTERM'));
